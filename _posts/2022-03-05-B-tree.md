---
layout: post
title: (Java) B-Tree
tags:
  - 자료구조_알고리즘
---

<br>

### B-Tree

---

> B-tree를 설명하기에 앞서 이진탐색트리(BST)에 대해 간단하게 리뷰하자. 먼저 이진탐색트리는 이진 트리의 한 종류로 최대 2개의 자식 노드를 가질 수 있다. 이진탐색트리는 임의의 한 노드를 기준으로 왼쪽 subtree는 노드보다 작은값, 오른쪽 subtree는 노드보다 큰값으로 구성된다. 이진탐색트리는 이러한 특징을 활용해 특정 노드를 찾을 때 루트노드부터 크기를 비교하면서 타고 들어간다. 따라서 검색의 평균 시간복잡도는 O(logN)이다. 하지만 트리가 균형을 이루지 못하고 한쪽으로 치우친다면 최악의 경우 O(N)의 시간복잡도를 가지게 된다. 이러한 문제점을 보완하기 위해 자료의 삽입, 삭제 시 스스로 균형을 맞추는 여러 balanced tree가 존재하는데 B-Tree와 B-+Tree도 그 중 하나이다. 

<br>

### B-Tree의 특징

- 하나의 노드에 여러개의 자료(키)가 존재한다. (이진트리는 하나의 노드에 하나의 자료만 존재)
- 최대 M개의 자식을 가지는 B-Tree를 M차 B-Tree 라고 한다. 
- M차 B-Tree에서 각 노드의 최대 key수는 M-1 이다.
- root node와 leaf node를 제외한 모든 node의 최소 자녀 노드수는 ⌈M/2⌉ 이다.
- root node를 제외한 모든 노드의 최소 key 는  ⌈M/2⌉-1 이다.
- 각 노드에 속한 자료는 정렬되어 있다.
- 노드에 속한 자료의 왼쪽 subtree는 자료보다 작은 값들을 가지고, 오른쪽 subtree는 자료보다 큰 값을 가진다
- 즉, 중복되는 자료가 존재하지 않는다.

<br>

#### 1. key 검색과정

- 루트노드에서 key값과 검색값을 비교하면서 하향식으로 순회

#### 2. key 삽입과정

- 삽입하기 적절한 리프노드를 찾아 삽입
  
  - 삽입한 리프노드에 key가 가득 차지 않았을 경우 ->  종료
  
  - 삽입한 리프노드의 key 갯수가 담을 수 있는 최대 key갯수를 초과한 경우 -> 분할 필요
    
    - 노드의 키값 중 중앙 값을 찾아 부모노드에 병합하고 왼쪽키는 왼쪽자식으로, 오른쪽 키는 오른쪽 자식으로 분할
    
    - 중앙값을 병합한 부모노드도 최대 key 갯수를 초과했을 경우 , 위 과정 반복

#### 3. key 삭제과정

- 삭제할 key가 리프노드에 있을 때
  
  - 해당 노드의 key갯수가 최소 key 갯수보다 클 경우 -> 삭제 후 종료
  
  - 해당 노드의 key갯수가 최소 key 갯수와 같을 경우 
    
    - 형제 노드에서 key값을 빌려오거나 (왼쪽 또는 오른쪽 형제 노드의 key갯수가 최소 key갯수보다 클 경우) 
    
    - 형제 노드와 결합한다. (왼쪽 또는 오른쪽 형제 노드의 key갯수가 최소 key갯수와 같을 때)

- 삭제할 key가 내부노드에 있을 때
  
  - 왼쪽 subtree중 가장 큰 값 또는 / 오른쪽 subtree 중 가장 작은값과 swap 
  
  - 위에서 고른 리프노드의 키값을 삭제하는 문제로 바뀐다. 

<br>