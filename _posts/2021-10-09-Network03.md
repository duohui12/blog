---
layout: post
title: (네트워크) Network Layer
tags:
  - 네트워크
---

<br>

### Network Layer

***

- 네트워크 계층은 중간 라우터를 통한 [라우팅](https://ko.wikipedia.org/wiki/라우팅)과 [패킷 포워딩](https://ko.wikipedia.org/w/index.php?title=패킷_포워딩&action=edit&redlink=1)을 담당한다.
- 라우터는 네트워크 레이어까지만 구현되어 있다.
- 라우터는 fowarding과 routing을 담당한다.
  - <b>forwarding</b> : 라우터로 들어온 패킷의 목적지를 보고 적절한 출력 포트로 내보내는 것
  - <b>routing</b> : 라우팅 알고리즘을 이용해 포워딩 테이블을 만드는 작업
- IP패킷의 헤더에는 source ip address, dest ip address, ttl, upper layer 등의 정보가 담겨있다.
- IP패킷의 데이터에는 상위 계층인 트랜스포트 계층의 세그먼트가 담긴다. 
- 현재 네트워크에서 사용되는 ip주소는 <b>IPv4</b>(32bit)이다
- IP주소는 사실 특정 호스트를 지칭하는 것이 아니라, 네트워크 인터페이스를 지칭한다.
  - 라우터 같은 경우에는 여러 인터페이스를 가진다. 즉, 여러 IP주소를 가진다.
- IPv4는 32bit로 구성되어 있고, Network ID 부분과 (=prefix =subnet), Host ID 부분으로 나뉜다.
  - 주소를 계층화하지 않으면 포워딩 테이블의 크기가 커지는 문제가 발생
- IP고갈 문제 -> 해결방법 : Private Network (하나의 Public Ip를 여러 기기가 공유하는 방법)

<br>

### [IPv4 클래스 분류](https://www.youtube.com/watch?v=0dFNpNgiTAA)

***

- IP 주소는 대역에 따라 A, B, C, D, E 등의 클래스로 나누어질 수 있습니다. 이 클래스들을 구분함으로서 클래스 내에 Network ID와 Host ID를 구분한다. 

- IPv4는 32bit 주소체계로, 8bit씩 나누면 네개의 옥텟으로 구성된다
  -  (ex. 255.255.255.255 / 11111111.11111111.11111111.11111111)
- 여기서 첫번째 옥텟이 클래스를 결정한다. 

| 클래스 | 첫째 옥텟의 최소값 (2진수) | 첫째 옥텟의 최대값 (2진수) | 첫째 옥텟의 값 범위 (10진수) | 이론적 IP주소 범위          | 사용                 |
| :----- | -------------------------- | -------------------------- | ---------------------------- | --------------------------- | -------------------- |
| A      | **0**000 0000              | **0**111 1111              | 0 - 127                      | 0.0.0.0 - 127.255.255.255   | 대규모 네트워크 환경 |
| B      | **10**00 0000              | **10**11 1111              | 128 - 191                    | 128.0.0.0 - 191.255.255.255 | 중규모 네트워크 환경 |
| C      | **110**0 0000              | **110**1 1111              | 192 - 223                    | 192.0.0.0 - 223.255.255.255 | 소규모 네트워크 환경 |
| D      | **1110** 0000              | **1110** 1111              | 224 - 239                    | 224.0.0.0 - 239.255.255.255 | 멀티캐스트용         |
| E      | **1111** 0000              | **1111** 1111              | 240 - 255                    | 240.0.0.0 - 255.255.255.255 | 연구개발용           |

- 또한 각 클래스 안에서 IP를 Network ID와 Host ID로 구분할 수 있다.
  - Class A : 첫 8bit가 Network ID 나머지 24bit가 Host ID (/8, 255.0.0.0)
  - Class B : 16bit가 Network ID 나머지 16bit가 Host ID (/16, 255.255.0.0)
  - Class C : 24bit가 Network ID 나머지 8bit가 Host ID (/24, 255.255.255.0)

<br>

### CIDR (Classless Inter-Domain Routing)

***

- IP 클래스의 비효율성 문제
  - IPv4는 초기에 클래스를 나누어서 IP를 할당함. 하지만 이 방식은 매우 비효율적이었음. 예를들어 한 중소기업이 클래스 B를 할당받았는데 (Host ID => 2^16, 대략 65000개) 65000여개의 IP를다 쓰는 것이 아닌 20000개 정도만 쓴다고 가정해보자. 나머지 40000여개의 IP는 사용하지 않으면서 클래스 B 하나를 점유하고 있는 상태가 된다. 그렇다고 클래스 C를 할당하자니 IP자원이 부족한 문제가 발생함

- 클래스 체계보다 더 유연하게 IP주소를 여러 네트워크 영역으로 나눌 수 있도록 CIDR 즉, 클래스 없는 도메인간 라우팅 기법을 사용하게 되었다.
- 사이더는 각 네트워크 대역을 구분짓고 구분된 네트워크간 통신을 위한 주소 체계이다. 

```markdown
예제로 살펴보기
### 192.168.1.0 /24
- 주소범위 : 192.168.1.0 ~ 192.168.1.255
- Network ID : 192.168.1.0 (192.168.1.00000000)
- Broadcast주소 : 192.168.1.255 (192.168.1.11111111)
- 사용가능 주소 범위 : 192.168.1.1 ~ 192.168.1.254
```

<br>

### NAT (Network Address Translation)

***

IPv4는 32bit 주소체계로 최대 2^32개(약 40억) 의 host를 유니크하게 지칭할 수 있다. 그런데 PC,모바일,태블릿 등 인터넷을 사용하는 디바이스가 늘어나면서 IP주소 고갈문제가 발생함. 그래서 IPv6를 디자인함. IPv6는 128bit의 주소공간(어마어마하게 큰 숫자.. 지구상의 존재하는 모든 디바이스를 넉넉하게 커버 가능함)을 가진다. 하지만 2021년인 현재까지도 IPv6가 아닌 IPv4를 사용하고 있다??!!! 왜?? 그리고 어떻게 이게 가능할까??

IPv6를 디자인했지만 지금까지 사용하지 못하고 있는 이유는 무엇일까? 현재 네트워크를 구성하고 있는 라우터들은 IPv4만 인식하도록 만들어져 있다. 그래서 IPv6를 사용하기 위해서는 존재하는 모든 라우터가 IPv6를 인식할 수 있도록 변경해야 한다. 하지만, 세상에 존재하는 라우터는 한 사람이 소유하고 있는 것이 아니기 때문에 IPv4생태계를 한번에 IPv6생태계로 바꾸는 건 쉽지 않은 일이다.   

그렇다면 또 다른 궁금증이 생긴다. 개인이 소유하는 디바이스(랩탑,모바일,태블릿,, 등등)뿐 아니라 라우터들도 IP주소를 가지고 있는 현재 시점에서 어떻게 IPv4주소가 고갈되지 않고 네트워크가 생태계가 잘 돌아가고 있는 것일까??

사실 IP 주소는 globally unique해야만 한다. (그래야 서로의 unique한 주소를 가지고 정확하게 통신할 수 있기 때문에), 하지만  IPv4는 2^32개의 주소만 unique하게 사용할 수 있기 때문에, 내부적으로만 unique한 주소를 배정하고 네트워크 외부로 나갈때는 globally unique한 gateway ip주소로 바꿔주는 트릭을 사용한다. 이 트릭을 위해 사용하는게 바로 **NAT (Network Address Translation)** 이다.

<br>

- NAT란 무엇일까??

  > **네트워크 주소 변환**([영어](https://ko.wikipedia.org/wiki/영어): network address translation, 줄여서 **NAT**)은 컴퓨터 네트워킹에서 쓰이는 용어로서, [IP](https://ko.wikipedia.org/wiki/IP) [패킷](https://ko.wikipedia.org/wiki/패킷)의 [TCP](https://ko.wikipedia.org/wiki/전송_제어_프로토콜)/[UDP](https://ko.wikipedia.org/wiki/사용자_데이터그램_프로토콜) 포트 숫자와 소스 및 목적지의 [IP 주소](https://ko.wikipedia.org/wiki/IP_주소) 등을 재기록하면서 [라우터](https://ko.wikipedia.org/wiki/라우터)를 통해 [네트워크 트래픽](https://ko.wikipedia.org/w/index.php?title=네트워크_트래픽&action=edit&redlink=1)을 주고 받는 기술을 말한다. NAT를 이용하는 이유는 대개 [사설 네트워크](https://ko.wikipedia.org/wiki/사설_네트워크)에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 [인터넷](https://ko.wikipedia.org/wiki/인터넷)에 접속하기 위함이다.  (출처 : [위키백과](https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EC%A3%BC%EC%86%8C_%EB%B3%80%ED%99%98) )

<br>

- 예제로 확인해보자

<img src="https://github.com/AmyJJung/blog/blob/main/images/Network/nat.png?raw=true" alt="스크린샷 2021-10-11 오후 4.24.40" style="zoom: 30%;" />

(출처 : Computer Networking: A Top-Down Approach)

 

1. host `10.0.0.1, 3345` 이 `128.119.40.186, 80(웹서버)` 로 데이터그램을 보낸다 

2. 이때 ip주소 `10.0.0.1`은 private ip주소이기 때문에 외부로 나갈 때 globally unique한 gateway ip주소로 바꿔서 나가게 되는데, 이 변환 정보를 NAT 테이블에 기록한다. 

   | WAN side addr     | LAN sid addr   |
   | ----------------- | -------------- |
   | 138.76.29.7, 5001 | 10.0.0.1, 3345 |

3. 웹서버(128.119.40.186, 80) 로 부터 요청에 대한 응답이 `138.76.29.7, 5001`로 돌아왔다.

4. 이 때 NAT에 기록된 정보를 확인해서 `138.76.29.7, 5001` 목적지를 `10.0.0.2, 3345` 로 변경한다.

5. 이렇게 해서 원래 요청을 보냈던 호스트인 `138.76.29.7, 5001`로 응답이 돌아옴.

<br>

- 위 예제를 보면 궁금증이 생긴다. NAT 테이블에 정보를 기록할 때 왜 포트번호를 변경하는 걸까??
  - 네트워크 내부에 여러 호스트가 존재하기 때문에, 호스트별로 같은 포트번호를 사용할 수 있다. 그럴 경우에 외부로 나갈 때 IP주소도 같아지고 포트번호도 같기 때문에, 돌아온 응답을 구별할수가 없게됨. 그래서 NAT 테이블을 작성할 때 구별이 가능한 서로다른 포트번호를 부여하기 위해 포트번호를 변경한다. 
- NAT의 문제점
  - NAT 테이블에는 Client로써 요청을 보낼때 정보가 적히게 된다. 만약 private ip로 서버를 운영할 경우에는? private ip가 globally unique하지 않기 때문에 외부에서 접속할 수 없음. 그렇다면 gateway ip를 알고 있어서 그 주소로 접속한다면? gateway까지는 패킷이 도착하지만 NAT 테이블에 내 웹서버의 포트번호에 대한 정보가 없어 찾아올 수 없다. 즉, privaet ip를 가지고 서버를 운영하기가 어렵다. (hole punching 기법을 사용하기도 함)
  - gateway라우터가 ip packet에 담긴 정보를 보고, ip주소를 변경함. 심지어 data에 들어있는 port번호까지 확인함. => **Layering Violation**

- 즉, IP주소가 아닌 Port번호를 호스트를 구별하는 데 사용해서 여러 문제가 발생하게 된다. 

<br>

### DHCP (Dynamic Host Configuration Protocol)

***

어떤 네트워크를 가더라도 IP주소를 배정해주는 서버(DHCP 서버) 가 존재한다. 

