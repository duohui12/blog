---
layout: post
title: (MSSQL) 저장 프로시저의 특징과 작동방식
tags:
  - MSSQL
---

<br>

> 참고 : 이것이 SQL Server다

<br>

### 저장 프로시저의 특징

---

1. SQL Server의 성능을 향상시킴
   - 저장 프로시저를 처음 실행할 때 최적화, 컴파일을 거쳐 그 결과가 메모리에 저장된다.
   - 그 후에 같은 저장 프로시저를 실행하면 메모리에 있는 것을 가져다 사용
   - 따라서, 저장 프로시저가 자주 사용될 경우에는 일반 쿼리를 반복해서 실행하는 것보다 SQL Server의 성능이 향상될 수 있다.
2. 유지관리가 간편
   - 클라이언트 응용 프로그램에 직접 SQL문을 작성하지 않고 저장 프로시저 이름만 호출 -> 유지보수가 쉬워진다
3. 모듈식 프로그래밍이 가능하다
   - 한번 저장 프로시저를 생성하면 언제든 실행이 가능하다. 
   - 또한 저장 프로시저로 저장해 놓은 쿼리 관리가 쉬워진다
4. 보안을 강화할 수 있다.
   - 사용자별로 테이블에 접근 권한을 주지 않고, 저장 프로시저에만 접근 권한을 줌으로써 보안을 강화할 수 있다.
   - 예) 고객의 모든 정보가 담긴 userTbl이 있다. 배송 담당자는 배송업무를 위해 userTbl에 있는 주소 정보에 접근해야 한다. 이때 배송 담당자에게 테이블 자체의 접근 권한을 주게되면 고객의 다른 정보까지 노출되는 문제가 발생한다. 하지만 고객의 주소 정보만 접근할 수 있는 저장 프로시저를 만들어서, 이 저장 프로시저에 대한 접근 권한만 준다면 보안을 강화할 수 있다.
5. 네트워크 전송량의 감소
   - 긴 코드로 구현된 쿼리를 실행할 때, 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송되어야한다. 하지만, 긴 코드의 쿼리를 서버에 저장 프로시저로 생성해 놓았다면, 클라이언트에서 저장프로시저 이름과 매개변수 등 몇 글자의 텍스트만 전송하면 되기 때문에 네트워크 부하를 크게 줄일 수 있음

<br>

<br>

### 저장 프로시저의 작동

---

- 일반 T-SQL의 작동 방식

  - `구문분석`(쿼리에 오타가 있는지..)-> `개체 이름 확인`(작성한 테이블명이 진짜 있는지...) -> `사용권한 확인` -> `최적화`(index사용 여부) -> `컴파일`(기계가 알아볼 수 있게, 바이너리 코드로 컴파일) 및 `실행계획 메모리에 등록` -> `실행`

  - 동일한 쿼리를 실행할 때 위 과정에서 메모리 확인 단계부터 반복한다.

  - 하지만, 완전하게 똑같은 SQL문의 실행이 아니라면(대문자, 소문자 다른 경우도 다른 구문으로 처리) 모든 과정을 처음부터 시작한다. 

  - ```sql
    SELECT * FROM userTbl WHERE = 'LSG'
    SELECT * FROM userTbl WHERE = 'KBS'
    
    -- 두 쿼리의 경우 조건만 다른데 모든 과정을 새로 반복한다. 비효율적 
    ```

<br>

- 저장 프로시저의 작동 방식

  - `CREATE PROCEDURE` -> `구문 분석` -> `지연된 이름 확인`(아직 안 만들어진 테이블이 있는지 확인) -> `생성권한 확인` -> `시스템 테이블에 등록` (저장 프로시저의 이름 및 텍스트)

  - 저장 프로시저 1회 실행시 (`EXEC`) : `개체이름 확인` -> `사용권한 확인` -> `최적화` -> `컴파일 및 실행계획 메모리 등록` -> `실행  `

  - 동일한 저장 프로시저를 사용할 때 메모리 확인 단계에서 반복한다. 

  - ```sql
    CREATE PROCEDURE usp_usrid
    	@id NVARCHAR(10)
    AS
    	SELECT * FROM userTbl WHERE userID = @id
    GO
    
    -- 이렇게 저장 프로시저를 저장해놓으면
    -- 파라미터가 달라도 저장프로시저가 똑같기 때문에 메모리에 컴파일 된걸 가져다 쓴다. 더 효율적
    
    EXEC(usp_userid,'LSG');
    EXEC(usp_userid,'KBS');
    ```

  -  하지만, 처음 최적화가 결정되면 계속 그 방식대로 쭉 재사용되기 때문에 문제가 발생하기도 한다. 이런 문제를 해결하기 위해 저장 프로시저를 다시 컴파일 해야한다. 
    - `EXECUTE` 문에 `WITH RECOMPILE` 옵션 사용
    - `CREATE PROCEDURE` 문에 `WITH RECOMPILE`  옵션 사용 
    - `sp_recompile 테이블이름` 시스템 저장 프로시저를 사용하면, 다음에 해당 테이블과 관련된 저장 프로시저를 사용시에 다시 컴파일
    - `DBCC FREEPROCCACHE` 를 사용하면 현재 메모리 (프로시저 캐시 영역)의 내용을 모두 비워 다음 저장 프로시저 실행시에 다시 컴파일

<br>

