---
layout: post
title: (책리뷰) 만들면서 배우는 클린 아키텍처
tags:
  - [책, 헥사고날아키텍처]
---

<br>

<img src="https://github.com/AmyJJung/blog/blob/main/images/hexagonal_architecture/clean-archi-book.jpeg?raw=true" alt="book_image" style="zoom:40%;" />

만들면서 배우는 클린 아키텍처 책을 읽고 개인 프로젝트에 적용해 본 내용을 정리해보려고 한다. 분량이 길지 않고 책이 가벼워서 들고다니면서 읽기 편했다. 

이 책에서는 기존 계층형 아키텍처의 문제점에 대해서 이야기한 후, 이런 문제점들을 해결하고 유지보수를 용이하도록 해주는 <b>헥사고날 아키텍처</b>에 대해 소개하고 있다. 그리고 웹 계층, 애플리케이션 계층, 영속성 계층의 구현방법과 각 계층의 경계에서 모델을 매핑하는 여러 방법에 대해서도 간단하게 설명하고 있다.

<br>

### 계층형 아키텍처의 한계

1장에서는 기존 계층형 아키텍처의 문제점에 대해서 이야기한다. 현재 내가 회사에서 유지보수 중인 한 서비스가 계층형 아키텍처이다 보니 평소에 느꼈던 내용이 나와서 공감되었다. 정리하자면 <b>계층형 아키텍처는 웹 계층 -> 도메인 계층 -> 영속성 계층으로 의존성 방향이 흘러가기 때문에</b>, 데이터베이스 주도 설계를 유도할 수 밖에 없다. 영속성 계층이 개발된 뒤에야 도메인 계층, 웹 계층을 개발할 수 있기 때문에 동시 작업이 어렵다는 문제도 있다. 또한 각 계층은 같은 계층이나 아래 계층에만 접근이 가능하기 때문에, 시간이 지남에 따라 자연스럽게 가장 아래 계층인 데이터베이스 계층에 유틸, 헬퍼 클래스들이 추가된다. 이에 따라 여러 계층에 책임이 섞이게 되고, 테스트가 어려워진다는 단점이 있다.

사실 애플리케이션에서 가장 중요한 부분은 도메인을 중심으로 한 비즈니스 로직일텐데, 이러한 계층형 아키텍처는 데이터베이스 계층의 변경사항에 따라 도메인 계층이 자주 변경되어야 하는 치명적인 단점이 생긴다. 이 책에서는 이런 문제를 해결할 수 있는 대안으로 헥사고날 아키텍쳐를 소개한다. 

<br><br>

### 단일 책임 원칙, 의존성 역전 원칙

2장에서는 이 문제의 대안으로 헥사고날 아키텍처에 대해 설명하기 전에 먼저 <b>SOLID원칙</b> 중에서 S에 해당하는 <b>단일 책임 원칙(Single Responsibility Principle)</b>과 D에 해당하는 <b>의존성 역전 원칙(Dependency Inversion Principle)</b>에 대해 소개한다. 

이 책을 읽기 전까지는 나는 단일 책임 원칙에 대해 '하나의 컴포넌트가 하나의 일만 하는 것' 이라고 생각했다. 하지만 이 책에서는 아래와 같이 단일 책임 원칙에 대해 설명하고 있다. 

> <b>단일 책임 원칙 : 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다</b>

그렇다면 위에서 설명한 계층형 아키텍처는 이 단일 책임 원칙을 잘 지키고 있다고 말할 수 있을까? 아니다. 왜냐하면 계층형 아키텍처에서 도메인 계층은 비즈니스 로직이 변경됨에 따라 수정되는 경우 외에도, 의존하고 있는 영속성 계층의 변경에 따라 수정될 수 있기 때문이다. 이러한 의존성을 제거하기 위해서 등장하는 개념이 의존성 역전 원칙이다. 

> <b>의존성 역전 원칙 : 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다</b>

도메인 계층이 영속성 계층을 의존하는 것이 아니라, 도메인 계층에 영속성 계층의 레포지토리를 추상화 한 인터페이스를 둔다. 그리고 도메인에서는 이 인터페이스를 사용하고, 영속성 계층은 이 인터페이스를 구현하도록 함으로써 두 계층 사이의 의존성을 끊을 수 있다. 

<br>

<br>

### 헥사고날 아키텍처 그리고 의존성 주입의 역할

그 다음으로는 위에서 정리한 단일 책임 원칙, 의존성 역전 원칙 컨셉이 녹아있는 헥사고날 아키텍처에 대해 설명한다.

<img src="https://github.com/AmyJJung/blog/blob/main/images/hexagonal_architecture/hexagonal.jpeg?raw=true" alt="hexagonal_architecture" style="zoom:40%;" />

위 그림에서 볼 수 있듯이 애플리케이션 코어가 육각형으로 표현되어 있어서 <b>헥사고날 아키텍처 (hexagonal architecture)</b>라고 불린다고 한다. 육각형에서 모든 의존성으로 내부로 향한다. 육각형 내부에 있는 애플리케이션 코어와 육각형 외부에 있는 어댑터들이 통신하려면 애플리케이션 코어가 포트를 제공해야 한다. 그래서 <b>포트와 어댑터 아킥텍처 (ports-and-adapters)</b> 라고도 불린다. 

여기서 포트는 아까 위에서 설명했듯이 육각형 내부에서 바깥으로 향하는 의존성을 끊기 위해 (의존성 역전 원칙)  도메인 계층에 추가하는 인터페이스라고 볼 수 있을 것 같다. 이렇게 하면 육각형 내부, 즉 도메인 로직을 변경해야 하는 이유는 비즈니스 로직이 수정되는 경우만 존재하게 될 것이다. (단일 책임 원칙)

<br>

헥사고날 아키텍처의 컨셉을 지키기 위해 꼭 필요한 개념으로 <b>의존성 주입</b>이 있다. 

<img src="https://github.com/AmyJJung/blog/blob/main/images/hexagonal_architecture/hexagonal-example.jpeg?raw=true" alt="dependency_injection" style="zoom:40%;" />

위 이미지에서 볼 수 있듯이 도메인 계층에는 `SendMoneyService` 에서는 영속성 어댑터를 사용하기 위해 도메인 계층에 있는 `LoadAccountPort` 인터페이스를 사용한다. 그리고 영속성 계층의 `AccountPersistenceAdapter` 는 `LoadAccountPort`를 구현한다. 

이렇게 개발한 이유는 결국 `SendMoneyService` 에서 도메인 계층에 존재하는 추상화된 포트만 사용하고 영속성 구현체는 의존하지 않기 위함이다. 그런데, `SendMoneyService` 에서 `LoadAccountPort` 인터페이스 타입의 변수를 사용한다고 해도 결국에는 그 구현체를 누군가 도메인 계층에 주입해줘야 한다. 그렇지 않으면 아래 코드처럼 도메인 계층에서 영속성 계층의 구현체 클래스를 직접 의존할 수 밖에 없게 되고 (추상/구현체를 분리해서 구현했음에도 불구하고) 어댑터에 변경에 따라 도메인 코드가 수정될 수 있다. 

```java
private LoadAccounPort loadAccountPort = new AccountPersistenceAdpater();
```

바로 이때 의존성 주입을 활용할 수 있다!

처음 스프링을 공부할 때는 의존성 주입 기능이 왜 필요한지 잘 모르고 너무 당연하게 사용했던 적이 있다. 그 당시에는 직접 구현체 클래스를 생성하지 않도록 도와주는 편리한 기능이구나 정도로만 생각했었다. 하지만 의존성 주입 기능의 핵심은 그것보다 훨씬 더 심오하다. 의존성 주입 기능이 있기 때문에 <b>SOLID원칙</b> 중에서 S에 해당하는 <b>단일 책임 원칙(Single Responsibility Principle)</b>과 D에 해당하는 <b>의존성 역전 원칙(Dependency Inversion Principle)</b>을 지킬 수 있게 되었고, 좀 더 세련되게, 객체지향적으로 설계하고 유지보수 할 수 있게 되었다. 

<br>

<br>

### 풍부한 도메인 모델 vs 빈약한 도메인 모델

풍부한 도메인 모델은 애플리케이션 코어에 있는 엔티티에 대부분의 도메인 로직을 구현한다. 반면 빈약한 도메인 모델에서는 엔티티는 상태를 표현하는 필드와 이 값을 바꾸기 위한 getter, setter 메서드만 포함한다. 그리고 대부분의 비즈니스 로직이 유스케이스 클래스에 구현되어 있다. 

이 책에서는 각자의 필요에 맞는 스타일을 택해서 사용하며 된다고 하는데, 나는 주로 빈약한 도메인 모델 방식으로 개발했던 것 같다. 풍부한 도메인 모델은 접해본 적이 별로 없는데 이부분은 DDD 관련해서 공부가 더 필요할 것 같다. 

<br>

<br>

### 경계간 매핑하기

이 아키텍처를 공부하면서 가장 헷갈렸던 부분이 바로 계층간 매핑 방법이었다. 이 책에서는 <b>매핑하지 않기 전략</b>,  <b>양방향 매핑 전략</b>,  <b>완전 매핑 전략</b>, <b>단방향 매핑 전략</b> 에 대해 소개한다. 

1. 매핑하지 않기 전략

   1. 모든 계층에서 도메인 모델을 공유하는 방식이다. 이럴 경우 웹 계층, 애플리케이션 계층, 영속성 계층과 관련된 이유로 도메인 모델이 변경될 수 있기 때문에 단일 책임 원칙을 위반한다.

2. 양방향 매핑 전략

   1. 각 계층에서 전용 모델을 가지고 있다. 각 계층에서 전용 모델을 번경하더라도 다른 계층에 영향이 없다. 
   2. 하지만, 도메인 모델이 계층 경계를 넘어서 통신하는 데 사용되는 단점이 있다. 즉 웹 계층에서 유스케이스 인터페이스를 호출할 때 도메인 모델로 변환해서 호출해야하고, 유스케이스에서 반환해주는 도메인 모델을 웹 계층 모델로 다시 변환해야한다(양방향 매핑). 영속성 계층도 동일하다. 따라서 도메인 모델이 바깥층 계층의 요구에 따른 변경에 취약해지게 된다. 
   
3. 완전 매핑 전략

   - 양방향 매핑 전략과 다르게 계층 경계를 넘어 통신할 때도 도메인 모델이 아닌 전용 모델을 사용한다. 단점은 너무 번거롭다. 하지만, 이렇게 개발할 경우 계층을 넘어 통신할 때 전용 모델에 유효성 검증 로직을 추가할 수 있고, 도메인 로직을 더럽히지 않을 수 있다. 

4. 단방향 매핑 전략
   - 

<br>

<br>

### 내 프로젝트에 적용해보기

사용자가 로그인을 하면 세션을 생성해서 로그인 정보를 저장한 후, 세션아이디가 기록된 쿠키를 발급해 준다. 그 후에 로그인 할 때는 쿠키에 담긴 세션아이디로 사용자 정보를 찾아서 자동로그인 시켜주는 간단한 기능을 구현해보았다. 

<img src="https://github.com/AmyJJung/blog/blob/main/images/hexagonal_architecture/tree.png?raw=true" alt="weblogin-project" style="zoom:50%;" />

영속성 계층인 `adapter/persistence` 패키지에 있는 Repository 구현 클래스들은 <b>package-private</b>접근 수준으로 작성했다. 그 이유는, 레포지토리 구현체들은 `application` 패키지 내에 있는 포트 인터페이스를 통하지 않고는 바깥에서 호출되지 않기 때문이다.

그리고 비즈니스 로직이 작성된 `application/service` 패키지의 Service 클래스들 역시 `adapter/web`에서 호출될 때 UseCase 인터페이스 뒤에 숨겨질 수 있기 때문에  <b>package-private</b>접근 수준으로 작성했다.

매핑 전략은 <b>양방향 매핑 전략</b>을 사용했다. 애플리케이션 계층과 통신할 수 있는 인터페이스인 port와 usecase에서는 매개변수 타입과 리턴 타입으로 도메인 모델을 사용했다. 

<br>

<br>

### 마치며

얇지만 이 책을 읽고 헥사고날 아키텍처의 컨셉에 대해서 배울 수 있어 유익했다. 또 아키텍처를 소개하는 책이지만 평소에 개발할 때 유지보수에 도움이 되는 다양한 개념(의존성 역전 원칙, 단일 책임 원칙, 의존성 주입)들을 정리해 볼 수 있는 좋은 기회였다고 생각한다.

또한 아무리 좋은 아키텍처라고 해도 나름의 장단점이 있기 때문에 각자 상황에 맞게 적용하는 유연성이 필요할 것 같다는 생각을 했다. 배운 아키텍처를 당장 내가 운영중인 서비스에 적용하지 못한다고 하더라고, 아키텍처가 탄생한 배경, 핵심 컨셉 등에 대해 이해하고 있으면 앞으로 새로운 프로젝트를 진행할 때 더 유연하게 생각할 수 있을 것 같다. 







